#include <iostream>
#include <TFile.h>
#include <TH1D.h>
#include <TF1.h>
#include <TCanvas.h>
#include <TMath.h>
#include <TMinuit.h>
#include <TRandom3.h>
#include <TStyle.h>
#include <TLegend.h>

// Generate Gaussian values and fill histogram
void GenerateGaussianValues(int nBins, double mean, double stdDev, TH1D *hist) {
    const double E_min = 1.8; // MeV
    const double E_max = 15.0; // MeV

    // Create a random number generator
    TRandom3 rand;
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    // what happens if you call this function twice? Will the two sets of random numbers be identical, or not? Why?
    // hen you fit the gaussian, there is also a normalisation. Please also fit it and tell me how to understand it. 
    // PS: the normalisation should be treated as a parameter to be fitted. 

    // Fill histogram with Gaussian-distributed values
    for (int ii = 0; ii < 1000; ii++) {
        double value = rand.Gaus(mean, stdDev);
        if (value >= E_min && value <= E_max) {
            hist->Fill(value);
        }
    }
}

void fcn(int &npar, double *gin, double &f, double *par, int iflag) {
    TH1D *hist = (TH1D*) gDirectory->Get("hist");
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    // can you add a const to protect it?
    //need to check if hist is NULL first. 
    //Could have made a mistake somewhere such that the "hist" is not found in the directory. 
    //Always check pointer first in such operations. 
    //can/should name it ff instead of f
    const int nBins = hist->GetNbinsX();
    const double binWidth = hist->GetBinWidth(1);

    double chiSquare = 0.0;
    for (int ii = 1; ii <= nBins; ii++) {
        double x = hist->GetBinCenter(ii);
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    // use xx instead of x, same logic as for ii
        double observed = hist->GetBinContent(ii);
        double expected = TMath::Gaus(x, par[0], par[1]) * hist->Integral() * binWidth;
    //////////////////////////////////////////////////////////////////////////////////////////////////////
    // need const to protect them

        if (expected > 0) {
            chiSquare += TMath::Power((observed - expected), 2) / expected;
        }
    /////////////////////////////////////////////////////////////////////////////////////////////////////
    //is the denominator correct?
    //please get the errors of the 3 parameters (normalisation, mean, sigma). 
    // On the other hand, you can call TH1::GetMeanError, GetRMSError, etc. 
    // Compare to your fitted error and tell me if they make sense.
    }
    f = chiSquare;
}

void minimizeChi2(double *fittedParams) {
    TMinuit *Minuit = new TMinuit(2); // Initialize TMinuit with 2 params (mean and sigma)
    Minuit->SetFCN(fcn);

    double arglist[10];
    int ierflg = 0;

    arglist[0] = 1;
    Minuit->mnexcm("SET ERR", arglist, 1, ierflg);

    // Set starting values and step sizes for parameters
    Minuit->mnparm(0, "Mean", 5.0, 0.1, 0.0, 10.0, ierflg);
    Minuit->mnparm(1, "Sigma", 1.0, 0.1, 0.0, 5.0, ierflg);

    // Now ready for minimization step
    arglist[0] = 500;
    arglist[1] = 1.;
    Minuit->mnexcm("MIGRAD", arglist, 2, ierflg);

    // Check convergence
    if (ierflg != 0) {
        std::cerr << "Minimization did not converge properly. Error code: " << ierflg << std::endl;
    }

    // Print results
    double amin, edm, errdef;
    int nvpar, nparx, icstat;
    Minuit->mnstat(amin, edm, errdef, nvpar, nparx, icstat);

    // Store the minimized parameters
    for (int ii = 0; ii < 2; ii++) {
        Minuit->GetParameter(ii, fittedParams[ii], edm);
    }

    delete Minuit;
}

void PlotGaussianFit(int nBins, TH1D *hist, double *fittedParams) {
    /////////////////////////////////////////////////////////////////////////////////////////////////////
    //still needs to protect the arguments
    // Create a canvas for plotting
    TCanvas *c1 = new TCanvas("c1", "Gaussian Fit", 800, 600);
    gStyle->SetOptStat(0);
    hist->Draw();

    // Create a Gaussian fit function
    TF1 *fitFunc = new TF1("fitFunc", "gaus", 1.8, 15.0);
    /////////////////////////////////////////////////////////////////////////////////////////////////////
    //what about the memory of fitFunc? Need to delete?
    fitFunc->SetParameters(fittedParams[0], fittedParams[1], hist->Integral()); // Set parameters (mean, sigma, amplitude)
    hist->Fit(fitFunc);
    //why do you fit the hist here? The plotted function is not affected by your minimizeChi2(fittedParams) anymore. 
    //The internal function parameters have been overwritten. 
    //After plotting, save the Canvas and histogram and function in a root file.



    // Draw the fitted function on the canvas
    fitFunc->SetLineColor(kRed);
    fitFunc->Draw("same");

    // Draw legend
    TLegend *leg = new TLegend(0.6, 0.7, 0.9, 0.9);
    leg->AddEntry(hist, Form("Generated Gaussian, \nMean: %.2f\n Sigma: %.2f", 5.0, 1.0), "l");
    leg->AddEntry(fitFunc, Form("Fitted Gaussian, \nMean: %.2f\n Sigma: %.2f", fittedParams[0], fittedParams[1]), "l");
    leg->Draw();

    // Save the canvas to a file
    c1->SaveAs("gaussian_fit.png");

    // Clean up
    delete fitFunc;
    delete c1;
}

int main() {
    const int nBins = 200;
    TH1D *hist = new TH1D("hist", "Generated Gaussian Data", nBins, 1.8, 15.0);
    double fittedParams[2];

    // Generate Gaussian values
    GenerateGaussianValues(nBins, 5.0, 1.0, hist);

    // Perform Gaussian fit using TMinuit
    minimizeChi2(fittedParams);

    // Plot the histogram and fit
    PlotGaussianFit(nBins, hist, fittedParams);

    // Clean up
    delete hist;

    return 0;
}
